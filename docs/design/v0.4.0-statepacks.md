# v0.4.0 Design: Explicit StatePacks

## Problem Statement

StatePacks in v0.3.x work but have three friction points:

1. **Registration is implicit** - Users define `states:` mapping but can't see what's registered until runtime fails
2. **Resolution order is hidden** - Builtins checked first, then pack keys - this surprises users
3. **No transition preview** - Users see states exist but not what messages trigger transitions

## Design Goal

Make StatePacks **explicit**, **inspectable**, and **unsurprising** without adding runtime complexity.

This is an introspection and ergonomics release, not a new runtime engine.

**Important constraint**: StatePack is introspection + registration metadata only. It is explicitly **not** an execution plugin system. Guards and transitions are labels for documentation and validation - they do not execute code or affect state machine behavior.

---

## Core Additions

### 1. StatePack Protocol

A `StatePack` is any object that implements:

```python
from typing import Protocol, Dict, Type, List, Optional
from dataclasses import dataclass

@dataclass
class StateSpec:
    """Specification for a single state."""
    state_class: Type[State]
    description: Optional[str] = None

@dataclass
class TransitionSpec:
    """Specification for a state transition."""
    from_state: str
    on_message: str  # Message type that triggers this
    to_state: str
    guard: Optional[str] = None  # Name of guard condition, if any
    description: Optional[str] = None

class StatePack(Protocol):
    """Protocol for state packs."""

    @property
    def name(self) -> str:
        """Pack identifier (e.g., 'session', 'cache')."""
        ...

    def provides(self) -> Dict[str, StateSpec]:
        """States this pack provides. Keys are registry names."""
        ...

    def transitions(self) -> List[TransitionSpec]:
        """Transitions between states in this pack."""
        ...

    def depends_on(self) -> set[str]:
        """State keys this pack requires but doesn't provide."""
        ...
```

### 2. Config Format (Additive)

**New format** (recommended):

```yaml
name: my_component
packs:
  - myapp.packs:SessionPack
  - myapp.packs:CachePack
initial_state: Idle
rules: []
```

**Old format** (still works, wrapped internally):

```yaml
name: my_component
states:
  Idle: "myapp.states:IdleState"
  Active: "myapp.states:ActiveState"
initial_state: Idle
rules: []
```

The old `states:` mapping is internally wrapped as an anonymous pack.

### 3. Resolution Rules

#### State Key Collisions

When multiple packs provide the same key:

| Scenario | Behavior |
|----------|----------|
| Pack A and Pack B both provide `Idle` | **Error** - collision detected at load time |
| Pack provides key matching builtin | **Error** - cannot shadow builtins |
| Same pack listed twice | **Warning** - deduplicated |

#### Initial State Resolution

Order:
1. Check pack-provided states first
2. Then check builtins
3. Error if not found in either

**Rationale**: Pack states are explicit user intent; builtins are fallbacks.

Optional config override:

```yaml
initial_state_resolution: ["builtin", "packs"]  # Legacy behavior
```

Default: `["packs", "builtin"]` (new behavior, v0.4.0+)

---

## explain() Enhancements

### New Fields in ConfigExplanation

```python
@dataclass
class PackResolution:
    """Resolution details for a state pack."""
    name: str
    dotted_path: Optional[str]
    resolved: bool
    provides: List[str]  # State keys
    depends_on: List[str]  # Required keys
    missing_deps: List[str]  # Unmet dependencies
    error: Optional[str] = None

@dataclass
class ConfigExplanation:
    # ... existing fields ...

    # New in v0.4.0
    packs: List[PackResolution] = field(default_factory=list)
    transitions: List[TransitionSpec] = field(default_factory=list)
    collisions: List[str] = field(default_factory=list)  # Duplicate keys
    resolution_order: List[str] = field(default_factory=list)  # ["packs", "builtin"]
```

### Enhanced format() Output

```
FlexiFlow Config Explanation
========================================
Source: config.yaml

Component:
  name: my_component
  initial_state: Idle
  rules: 2 rule(s)

Packs:
  ✓ SessionPack (myapp.packs:SessionPack)
      provides: Idle, Active, Suspended
      depends_on: (none)
  ✓ CachePack (myapp.packs:CachePack)
      provides: CacheWarm, CacheCold
      depends_on: (none)

States:
  ✓ Idle (from SessionPack)
  ✓ Active (from SessionPack)
  ✓ Suspended (from SessionPack)
  ✓ CacheWarm (from CachePack)
  ✓ CacheCold (from CachePack)
  Built-in: AwaitingConfirmation, ErrorHandling, InitialState, ProcessingRequest

Transitions: 8
  Idle --[start]--> Active
  Active --[suspend]--> Suspended
  Active --[complete]--> Idle
  Suspended --[resume]--> Active
  ...

Resolution Order: packs → builtin

Status: ✓ Valid - config will load successfully
```

---

## Implementation Plan

### Phase 1: Core Protocol (PR #14)

1. Add `StateSpec`, `TransitionSpec`, `StatePack` protocol to `flexiflow/packs.py`
2. Add `PackResolution` to `flexiflow/explain.py`
3. No config changes yet - just the types

### Phase 2: Mapping Adapter (PR #15)

1. Create `MappingPack` that wraps `states:` dict into a StatePack
2. Update `ConfigLoader` to create `MappingPack` from existing configs
3. Backward compatible - all v0.3.x configs still work

### Phase 3: Pack Loading (PR #16)

1. Add `packs:` config support
2. Load packs via dotted paths
3. Collision detection
4. Update `explain()` to show pack details

### Phase 4: Transitions (PR #17)

1. Add `transitions()` to protocol
2. Update `explain()` to show transition summary
3. Add `transitions` field to `ConfigExplanation`

### Phase 5: Resolution Order (PR #18)

1. Add `initial_state_resolution` config option
2. Implement new default: packs-first
3. Surface resolution order in `explain()`

---

## Migration Path

### v0.3.x → v0.4.0

**No breaking changes required.**

- `states:` mapping continues to work
- Default resolution order changes (packs first), but:
  - Only affects configs with custom states AND builtins with same name
  - This is rare and usually a bug anyway
  - `explain()` will warn if resolution order matters

### Deprecation Timeline

| Version | Status |
|---------|--------|
| v0.4.0 | `states:` works, `packs:` introduced |
| v0.5.0 | `states:` emits deprecation warning |
| v0.6.0 | `states:` removed (maybe - depends on adoption) |

---

## Open Questions

1. **Should packs be instantiated or class-based?**
   - Proposal: Class-based with `@staticmethod` or `@classmethod` for manifest methods
   - Alternative: Instances allow runtime configuration

2. **Should transitions be required or optional?**
   - Proposal: Optional (empty list = no transition manifest)
   - Rationale: Not all states have declarative transitions

3. **Should we add a CLI command?**
   - `flexiflow explain config.yaml` would be nice
   - Defer to v0.4.1 if needed

---

## Success Criteria

- [ ] `explain()` shows pack attribution for each state
- [ ] `explain()` shows transitions summary
- [ ] Collision detection works at load time
- [ ] Resolution order is explicit and configurable
- [ ] All v0.3.x configs work unchanged
- [ ] 0 new runtime dependencies
